#!/usr/bin/env bash
set -euo pipefail

print_banner() {
  printf '\n\033[1;36m'
  printf '==============================================\n'
  printf '        MediaBlade COMPLETE Setup  v3.0       \n'
  printf '   Docker Stack + Auto-Organizer Service      \n'
  printf '==============================================\n'
  printf '\033[0m\n'
}

main() {
  print_banner

  # === STEP 1: Ask for MediaBlade root ===
  local ROOT
  read -rp "Enter MediaBlade root (e.g. /srv/mediablade): " ROOT

  if [[ -z "$ROOT" || "$ROOT" != /* ]]; then
    echo "Error: Root must be an absolute path (start with /)" >&2
    exit 1
  fi

  mkdir -p "$ROOT"
  cd "$ROOT"
  echo "Using MediaBlade root: $ROOT"

  # === STEP 2: Optional Discord webhook ===
  local WEBHOOK
  read -rp "Discord webhook URL (press Enter to skip): " WEBHOOK
  WEBHOOK="${WEBHOOK:-}"

  # === STEP 3: Install Docker (if needed) ===
  echo
  echo "=== Checking/Installing Docker ==="
  if ! command -v docker >/dev/null 2>&1; then
    echo "Docker not found, installing via convenience script..."
    curl -fsSL https://get.docker.com -o get-docker.sh
    sh get-docker.sh
    usermod -aG docker "$(id -u -n)" || true
    systemctl enable --now docker
  else
    echo "Docker already installed."
  fi

  # === STEP 4: Create directory structure ===
  echo
  echo "=== Creating MediaBlade directories ==="
  mkdir -p \
    "$ROOT/media/movies" \
    "$ROOT/media/tv" \
    "$ROOT/downloads/incomplete" \
    "$ROOT/downloads/complete" \
    "$ROOT/downloads/jackett" \
    "$ROOT/tdarr_cache" \
    "$ROOT/traefik/letsencrypt"

  # Write a .env with safer defaults (and correct UID/GID)
  if [[ ! -f "$ROOT/.env" ]]; then
    local TZ_VALUE="Etc/UTC"
    if [[ -f /etc/timezone ]]; then
      TZ_VALUE="$(tr -d '\n' < /etc/timezone || echo 'Etc/UTC')"
    fi

    cat > "$ROOT/.env" << EOF
# MediaBlade generated defaults (edit as needed)
BIND_IP=127.0.0.1
TZ=${TZ_VALUE}
MEDIABLADE_UID=$(id -u)
MEDIABLADE_GID=$(id -g)

# Optional: Traefik reverse proxy
TRAEFIK_ENABLE=false
LETSENCRYPT_EMAIL=you@example.com
JELLYFIN_HOST=jellyfin.example.com
MEDIAMANAGER_HOST=mediamanager.example.com
WIZARR_HOST=wizarr.example.com

# Optional: Tdarr NVIDIA GPU
TDARR_NVIDIA_GPUS=0
EOF
  fi

  # === STEP 5: Generate docker-compose.yml ===
  echo
  echo "=== Writing docker-compose.yml ==="
  cat > "$ROOT/docker-compose.yml" << 'EOF'
name: mediablade

x-logging: &default-logging
  driver: json-file
  options:
    max-size: ${LOG_MAX_SIZE:-10m}
    max-file: "${LOG_MAX_FILE:-3}"

x-security: &default-security
  init: true
  security_opt:
    - no-new-privileges:true
  cap_drop:
    - ALL
  restart: unless-stopped
  logging: *default-logging

networks:
  media:
    driver: bridge
  proxy:
    driver: bridge

volumes:
  jellyfin_cache:
  jellyfin_config:
  jackett_config:
  rdtclient_config:
  bazarr_config:
  tdarr_config:
  tdarr_logs:
  tdarr_server_config:
  mediamanager_config:
  wizarr_config:

services:
  traefik:
    image: traefik:v3.3
    profiles: ["proxy"]
    container_name: mediablade-traefik
    networks: [proxy]
    ports:
      - "${TRAEFIK_BIND_IP:-0.0.0.0}:80:80"
      - "${TRAEFIK_BIND_IP:-0.0.0.0}:443:443"
    command:
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=${TRAEFIK_DOCKER_NETWORK:-mediablade_proxy}"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.${TRAEFIK_CERTRESOLVER:-le}.acme.email=${LETSENCRYPT_EMAIL}"
      - "--certificatesresolvers.${TRAEFIK_CERTRESOLVER:-le}.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.${TRAEFIK_CERTRESOLVER:-le}.acme.tlschallenge=true"
      - "--api.dashboard=${TRAEFIK_DASHBOARD:-false}"
      - "--log.level=${TRAEFIK_LOG_LEVEL:-INFO}"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik/letsencrypt:/letsencrypt
    <<: *default-security

  jellyfin:
    image: jellyfin/jellyfin:latest
    container_name: mediablade-jellyfin
    networks: [media, proxy]
    user: "${MEDIABLADE_UID:-1000}:${MEDIABLADE_GID:-1000}"
    environment:
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - jellyfin_config:/config
      - jellyfin_cache:/cache
      - ./media:/media
    ports:
      - "${BIND_IP:-127.0.0.1}:8096:8096"
    labels:
      - "traefik.enable=${TRAEFIK_ENABLE:-false}"
      - "traefik.docker.network=${TRAEFIK_DOCKER_NETWORK:-mediablade_proxy}"
      - "traefik.http.routers.jellyfin.rule=Host(`${JELLYFIN_HOST:-jellyfin.local}`)"
      - "traefik.http.routers.jellyfin.entrypoints=${TRAEFIK_ENTRYPOINTS:-websecure}"
      - "traefik.http.routers.jellyfin.tls=${TRAEFIK_TLS:-true}"
      - "traefik.http.routers.jellyfin.tls.certresolver=${TRAEFIK_CERTRESOLVER:-le}"
      - "traefik.http.services.jellyfin.loadbalancer.server.port=8096"
    <<: *default-security

  jackett:
    image: lscr.io/linuxserver/jackett:latest
    container_name: mediablade-jackett
    networks: [media]
    environment:
      - PUID=${MEDIABLADE_UID:-1000}
      - PGID=${MEDIABLADE_GID:-1000}
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - jackett_config:/config
      - ./downloads/jackett:/downloads
    ports:
      - "${BIND_IP:-127.0.0.1}:9117:9117"
    <<: *default-security

  rdtclient:
    image: rogerfar/rdtclient:latest
    container_name: mediablade-rdtclient
    networks: [media]
    environment:
      - PUID=${MEDIABLADE_UID:-1000}
      - PGID=${MEDIABLADE_GID:-1000}
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - rdtclient_config:/data/db
      - ./downloads:/data/downloads
    ports:
      - "${BIND_IP:-127.0.0.1}:6500:6500"
    <<: *default-security

  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: mediablade-flaresolverr
    networks: [media]
    environment:
      - LOG_LEVEL=info
      - LOG_HTML=false
      - CAPTCHA_SOLVER=none
      - TZ=${TZ:-Etc/UTC}
    ports:
      - "${BIND_IP:-127.0.0.1}:8191:8191"
    <<: *default-security

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: mediablade-bazarr
    networks: [media]
    environment:
      - PUID=${MEDIABLADE_UID:-1000}
      - PGID=${MEDIABLADE_GID:-1000}
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - bazarr_config:/config
      - ./media:/media
    ports:
      - "${BIND_IP:-127.0.0.1}:6767:6767"
    <<: *default-security

  tdarr:
    image: ghcr.io/haveagitgat/tdarr:latest
    container_name: mediablade-tdarr
    networks: [media]
    environment:
      - PUID=${MEDIABLADE_UID:-1000}
      - PGID=${MEDIABLADE_GID:-1000}
      - TZ=${TZ:-Etc/UTC}
      - serverIP=0.0.0.0
      - serverPort=8266
      - webUIPort=8265
      - NVIDIA_DRIVER_CAPABILITIES=${NVIDIA_DRIVER_CAPABILITIES:-compute,video,utility}
      - NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-}
    volumes:
      - tdarr_config:/app/configs
      - tdarr_logs:/app/logs
      - tdarr_server_config:/app/server
      - ./media:/media
      - ./tdarr_cache:/temp
    device_requests:
      - driver: nvidia
        count: ${TDARR_NVIDIA_GPUS:-0}
        capabilities: [gpu]
    ports:
      - "${BIND_IP:-127.0.0.1}:8265:8265"
      - "${BIND_IP:-127.0.0.1}:8266:8266"
    <<: *default-security

  mediamanager:
    image: ghcr.io/maxdorninger/mediamanager/mediamanager:latest
    container_name: mediablade-mediamanager
    networks: [media, proxy]
    environment:
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - mediamanager_config:/app/data
      - ./media:/media
    ports:
      - "${BIND_IP:-127.0.0.1}:8787:8787"
    labels:
      - "traefik.enable=${TRAEFIK_ENABLE:-false}"
      - "traefik.docker.network=${TRAEFIK_DOCKER_NETWORK:-mediablade_proxy}"
      - "traefik.http.routers.mediamanager.rule=Host(`${MEDIAMANAGER_HOST:-mediamanager.local}`)"
      - "traefik.http.routers.mediamanager.entrypoints=${TRAEFIK_ENTRYPOINTS:-websecure}"
      - "traefik.http.routers.mediamanager.tls=${TRAEFIK_TLS:-true}"
      - "traefik.http.routers.mediamanager.tls.certresolver=${TRAEFIK_CERTRESOLVER:-le}"
      - "traefik.http.services.mediamanager.loadbalancer.server.port=8787"
    <<: *default-security

  wizarr:
    image: ghcr.io/wizarrrr/wizarr:latest
    container_name: mediablade-wizarr
    networks: [media, proxy]
    environment:
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - wizarr_config:/data
    ports:
      - "${BIND_IP:-127.0.0.1}:5690:5690"
    labels:
      - "traefik.enable=${TRAEFIK_ENABLE:-false}"
      - "traefik.docker.network=${TRAEFIK_DOCKER_NETWORK:-mediablade_proxy}"
      - "traefik.http.routers.wizarr.rule=Host(`${WIZARR_HOST:-wizarr.local}`)"
      - "traefik.http.routers.wizarr.entrypoints=${TRAEFIK_ENTRYPOINTS:-websecure}"
      - "traefik.http.routers.wizarr.tls=${TRAEFIK_TLS:-true}"
      - "traefik.http.routers.wizarr.tls.certresolver=${TRAEFIK_CERTRESOLVER:-le}"
      - "traefik.http.services.wizarr.loadbalancer.server.port=5690"
    <<: *default-security
EOF

  # === STEP 6: Install Python + requests via apt (24.04-safe) ===
  echo
  echo "=== Installing Python + requests (apt) ==="
  apt update -y
  apt install -y python3 python3-requests

  # === STEP 7: Write media_organizer.py ===
  echo
  echo "=== Writing media_organizer.py ==="
  cat > "$ROOT/media_organizer.py" << 'EOF'
#!/usr/bin/env python3
"""
MediaBlade Organizer v2.1 - Ubuntu 24.04 friendly
Organizes movies and TV + optional Discord webhook summary.
"""

import re
import shutil
import argparse
from datetime import datetime
from pathlib import Path
from typing import List, Tuple, Optional
import logging

import requests  # installed via python3-requests

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class MediaOrganizer:
    def __init__(self, root_path: str, dry_run: bool = False, discord_webhook: Optional[str] = None):
        self.root = Path(root_path)
        self.movies_root = self.root / "media" / "movies"
        self.tv_root = self.root / "media" / "tv"
        self.dry_run = dry_run
        self.discord_webhook = discord_webhook

        self.video_exts = {".mkv", ".mp4", ".avi", ".m4v", ".mov", ".wmv", ".flv"}
        self.subtitle_exts = {".srt", ".ass", ".ssa", ".sub", ".idx"}

        self.summary = {
            "movies_organized": 0,
            "movies_skipped": 0,
            "tv_organized": 0,
            "tv_skipped": 0,
        }

    # ---------- Discord ----------

    def send_discord(self, title: str, message: str, color: str = "success") -> None:
        if not self.discord_webhook:
            return

        colors = {"success": 0x00FF00, "warning": 0xFF9900, "error": 0xFF0000}
        embed = {
            "title": f"üé¨ {title}",
            "description": message,
            "color": colors.get(color, 0x00FF00),
            "timestamp": datetime.utcnow().isoformat(),
            "footer": {"text": "MediaBlade Organizer"},
        }

        try:
            requests.post(self.discord_webhook, json={"embeds": [embed]}, timeout=10)
        except Exception as e:
            logger.error("Discord send failed: %s", e)

    # ---------- Parsing helpers ----------

    def parse_movie_filename(self, filename: str) -> Optional[Tuple[str, int]]:
        patterns = [
            r"^(.+?)[. _-]+(?P<year>\d{4})[. _]",
            r"^(.+?)[. _]*\(?(?P<year>\d{4})\)?[. _]",
        ]
        filename = re.sub(r"[\[\]]", "", filename)
        for pattern in patterns:
            m = re.match(pattern, filename, re.IGNORECASE)
            if not m:
                continue
            title = (
                m.group(1)
                .strip(".- ")
                .replace(".", " ")
                .replace("_", " ")
                .strip()
            )
            year = int(m.group("year"))
            if 1900 <= year <= 2026:
                return title, year
        return None

    def parse_tv_filename(self, filename: str) -> Optional[Tuple[str, int, int, str]]:
        patterns = [
            r"^(?P<show>.+?)[. _]+S(?P<season>\d+)[. _]*E(?P<episode>\d+)(?:[._-].*)?(?P<title>.*)?[. _]",
            r"^(?P<show>.+?)[. _]+(?P<season>\d+)x(?P<episode>\d+)(?:[._-].*)?(?P<title>.*)?[. _]",
        ]
        filename = re.sub(r"[\[\]]", "", filename)
        for pattern in patterns:
            m = re.match(pattern, filename, re.IGNORECASE)
            if not m:
                continue
            show = (
                m.group("show")
                .strip(".- ")
                .replace(".", " ")
                .replace("_", " ")
                .strip()
            )
            season = int(m.group("season"))
            episode = int(m.group("episode"))
            title = m.group("title").strip(".- ") if m.group("title") else f"Episode {episode}"
            return show, season, episode, title
        return None

    # ---------- File helpers ----------

    def get_video_files(self, path: Path) -> List[Path]:
        files: List[Path] = []
        for ext in self.video_exts:
            files.extend(path.rglob(f"*{ext}"))
        return sorted(files)

    def find_associated_subs(self, video_path: Path) -> List[Path]:
        subs: List[Path] = []
        stem = video_path.stem
        for ext in self.subtitle_exts:
            subs.extend(video_path.parent.glob(f"{stem}*{ext}"))
        return sorted(subs)

    # ---------- Movie handling ----------

    def organize_movie(self, video_path: Path) -> None:
        parsed = self.parse_movie_filename(video_path.name)
        if not parsed:
            self.summary["movies_skipped"] += 1
            return

        title, year = parsed
        dest_folder = self.movies_root / f"[{title}] [{year}]"

        if dest_folder == video_path.parent:
            self.summary["movies_skipped"] += 1
            return

        logger.info("üìΩÔ∏è  [%s] [%s] <- %s", title, year, video_path.name)

        if not self.dry_run:
            dest_folder.mkdir(parents=True, exist_ok=True)
            shutil.move(str(video_path), str(dest_folder / video_path.name))
            for sub in self.find_associated_subs(video_path):
                if sub.exists():
                    shutil.move(str(sub), str(dest_folder / sub.name))

        self.summary["movies_organized"] += 1

    def run_movies(self) -> None:
        logger.info("üé¨ Scanning movies: %s", self.movies_root)
        videos = self.get_video_files(self.movies_root)
        logger.info("Found %d movie files", len(videos))
        for v in videos:
            self.organize_movie(v)

    # ---------- TV handling ----------

    def organize_tv(self, video_path: Path) -> None:
        parsed = self.parse_tv_filename(video_path.name)
        if not parsed:
            self.summary["tv_skipped"] += 1
            return

        show, season, episode, title = parsed
        show_year = 2025  # Placeholder until you add real metadata
        show_folder = self.tv_root / f"[{show}] [{show_year}]"
        season_folder = show_folder / f"Season {season} [{show_year}]"
        new_name = f"EP{episode} - {title} [{show_year}]{video_path.suffix}"
        dest_video = season_folder / new_name

        if season_folder == video_path.parent and video_path.name == new_name:
            self.summary["tv_skipped"] += 1
            return

        logger.info("üì∫ [%s] S%02dE%02d <- %s", show, season, episode, video_path.name)

        if not self.dry_run:
            season_folder.mkdir(parents=True, exist_ok=True)
            shutil.move(str(video_path), str(dest_video))
            for sub in self.find_associated_subs(video_path):
                if sub.exists():
                    new_sub = season_folder / f"{new_name.rsplit('.',1)[0]}{sub.suffix}"
                    shutil.move(str(sub), str(new_sub))

        self.summary["tv_organized"] += 1

    def run_tv(self) -> None:
        logger.info("üì∫ Scanning TV: %s", self.tv_root)
        videos = self.get_video_files(self.tv_root)
        logger.info("Found %d TV files", len(videos))
        for v in videos:
            self.organize_tv(v)

    # ---------- Main ----------

    def run(self) -> None:
        start = datetime.now()
        logger.info("MediaBlade Organizer starting at %s", self.root)
        self.run_movies()
        self.run_tv()
        elapsed = (datetime.now() - start).total_seconds()

        msg = (
            f"Movies: {self.summary['movies_organized']} organized, "
            f"{self.summary['movies_skipped']} skipped\n"
            f"TV: {self.summary['tv_organized']} organized, "
            f"{self.summary['tv_skipped']} skipped\n"
            f"Runtime: {elapsed:.0f}s"
        )

        total = self.summary["movies_organized"] + self.summary["tv_organized"]
        if total > 0:
            self.send_discord("‚úÖ Media Organized", msg, "success")
        else:
            self.send_discord("‚ÑπÔ∏è No Changes", "No new media to organize", "warning")

        logger.info("Done. %s", msg)


def main() -> None:
    parser = argparse.ArgumentParser(description="MediaBlade Media Organizer")
    parser.add_argument("root_path", nargs="?", default=".")
    parser.add_argument("--movies-only", action="store_true")
    parser.add_argument("--tv-only", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    parser.add_argument("--discord-webhook")
    args = parser.parse_args()

    organizer = MediaOrganizer(
        root_path=args.root_path,
        dry_run=args.dry_run,
        discord_webhook=args.discord_webhook,
    )

    if args.movies_only:
        organizer.run_movies()
    elif args.tv_only:
        organizer.run_tv()
    else:
        organizer.run()


if __name__ == "__main__":
    main()
EOF

  chmod +x "$ROOT/media_organizer.py"

  # === STEP 8: systemd units ===
  echo
  echo "=== Writing systemd units ==="

  # Docker stack service
  cat > /etc/systemd/system/mediablade.service << EOF
[Unit]
Description=MediaBlade Docker Stack
After=docker.service network-online.target
Requires=docker.service

[Service]
Type=oneshot
WorkingDirectory=${ROOT}
ExecStart=/usr/bin/docker compose up -d
ExecStop=/usr/bin/docker compose down
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

  # Organizer service
  local ORG_ARGS=""
  if [[ -n "$WEBHOOK" ]]; then
    ORG_ARGS="--discord-webhook=${WEBHOOK}"
  fi

  cat > /etc/systemd/system/mediablade-organizer.service << EOF
[Unit]
Description=MediaBlade Media Organizer
After=mediablade.service network-online.target

[Service]
Type=oneshot
WorkingDirectory=${ROOT}
ExecStart=/usr/bin/python3 ${ROOT}/media_organizer.py . ${ORG_ARGS}
User=$(id -u)
Group=$(id -g)
StandardOutput=append:${ROOT}/organizer.log
StandardError=append:${ROOT}/organizer.log
TimeoutStartSec=300

[Install]
WantedBy=multi-user.target
EOF

  # Organizer timer
  cat > /etc/systemd/system/mediablade-organizer.timer << 'EOF'
[Unit]
Description=Run MediaBlade Organizer hourly
Requires=mediablade-organizer.service

[Timer]
OnCalendar=hourly
Persistent=true
RandomizedDelaySec=300

[Install]
WantedBy=timers.target
EOF

  # === STEP 9: enable + start ===
  echo
  echo "=== Enabling services and starting stack ==="
  systemctl daemon-reload
  systemctl enable mediablade.service mediablade-organizer.timer
  systemctl start mediablade.service
  systemctl start mediablade-organizer.timer

  # Quick dry-run test
  echo
  echo "=== Running organizer dry-run test ==="
  /usr/bin/python3 "$ROOT/media_organizer.py" . --dry-run || true

  echo
  echo "=============================================="
  echo " MediaBlade installation complete!"
  echo " Stack root: $ROOT"
  echo "----------------------------------------------"
  echo "By default, ports are bound to localhost."
  echo "If you're using a reverse proxy, enable it with:"
  echo "  docker compose --profile proxy up -d"
  echo
  echo "Local URLs (on the host):"
  echo "Jellyfin:      http://127.0.0.1:8096"
  echo "MediaManager:  http://127.0.0.1:8787"
  echo "Wizarr:        http://127.0.0.1:5690"
  echo "Jackett:       http://127.0.0.1:9117"
  echo
  echo "Check services:"
  echo "  systemctl status mediablade.service"
  echo "  systemctl status mediablade-organizer.timer"
  echo
  echo "Logs:"
  echo "  docker compose logs -f      (in $ROOT)"
  echo "  tail -f $ROOT/organizer.log"
  echo "=============================================="
}

main "$@"

